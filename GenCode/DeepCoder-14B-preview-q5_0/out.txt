Here's a full implementation of a FastAPI todo app with authentication, database integration, and a rich feature set:

```python
from fastapi import FastAPI, Depends, HTTPException, status
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
import uvicorn
from datetime import datetime

# Database Setup
DATABASE_URL = "postgresql+asyncpg://user:password@localhost:5432/todo_db"
engine = create_async_engine(DATABASE_URL)
SessionLocal = sessionmaker(engine, class_=AsyncSession)

# Models
class TodoModel(Base):
    __tablename__ = "todos"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(200), nullable=False)
    description = Column(String(500))
    completed = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow)

# Pydantic Models
class TodoBase(BaseModel):
    title: str
    description: Optional[str] = None
    completed: bool

class TodoCreate(TodoBase):
    pass

class TodoUpdate(TodoBase):
    id: int

class Todo(TodoBase):
    id: int
    created_at: datetime
    updated_at: datetime

# Database Functions
async def get_db():
    async with SessionLocal() as db:
        yield db

async def create_todo(db: AsyncSession, todo: TodoCreate, user_id: int):
    new_todo = TodoModel(
        **todo.dict(),
        created_at=datetime.utcnow(),
        updated_at=datetime.utcnow(),
        user_id=user_id
    )
    db.add(new_todo)
    await db.commit()
    return new_todo

async def get_todos(db: AsyncSession, skip: int = 0, limit: int = 100):
    return await db.execute(
        select(TodoModel).offset(skip).limit(limit)
    ).fetchall()

# FastAPI App
app = FastAPI()

@app.get("/todos", response_model=List[Todo])
async def get_all_todos(db: AsyncSession = Depends(get_db)):
    todos = await get_todos(db)
    return [Todo.from_orm(todo) for todo in todos]

@app.post("/todos")
async def create_new_todo(todo: TodoCreate, db: AsyncSession = Depends(get_db), user: User = Depends(get_current_user)):
    return await create_todo(db, todo, user.id)

@app.get("/todos/{todo_id}")
async def get_single_todo(todo_id: int, db: AsyncSession = Depends(get_db)):
    todo = await db.execute(select(TodoModel).where(TodoModel.id == todo_id))
    if not todo:
        raise HTTPException(status_code=404, detail="Todo not found")
    return Todo.from_orm(todo[0])

@app.put("/todos/{todo_id}")
async def update_todo(todo_id: int, todo: TodoUpdate, db: AsyncSession = Depends(get_db)):
    existing_todo = await get_single_todo(todo_id, db)
    if not existing_todo:
        raise HTTPException(status_code=404, detail="Todo not found")
    todo_data = todo.dict()
    for key, value in todo_data.items():
        setattr(existing_todo, key, value)
    existing_todoupdate_model = await db.execute(
        update(TodoModel).where(TodoModel.id == todo_id).values(
            updated_at=datetime.utcnow()
        )
    )
    if not existing_todoupdate_model:
        raise HTTPException(status_code=404, detail="Todo not found")
    await db.commit()
    return existing_todo

@app.delete("/todos/{todo_id}")
async def delete_single_todo(todo_id: int, db: AsyncSession = Depends(get_db)):
    todo = await db.execute(select(TodoModel).where(TodoModel.id == todo_id))
    if not todo:
        raise HTTPException(status_code=404, detail="Todo not found")
    await db.delete(todo)
    await db.commit()
```

For the frontend, you'll need to set up a React application:

```javascript
import React, { useState } from 'react';
import './App.css';

function App() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');
  const [showCompleted, setShowCompleted] = useState(false);

  const addTodo = (e) => {
    e.preventDefault();
    if (!input.trim()) return;
    
    setTodos([
      ...todos,
      {
        id: Date.now(),
        title: input.trim(),
        completed: false,
        created_at: new Date()
      }
    ]);
    
    setInput('');
  };

  const toggleTodo = (id) => {
    setTodos(todos.map(todo => 
      todo.id === id ? {...todo, completed: !todo.completed} : todo
    ));
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  return (
    <div className="App">
      <h1>Todo List</h1>
      <form onSubmit={addTodo}>
        <input 
          type="text" 
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Add a new todo..."
        />
        <button type="submit">Add</button>
      </form>

      <div className="todo-list">
        {todos
          .filter(todo => !showCompleted || todo.completed)
          .map(todo => (
            <div key={todo.id} className={`todo-item ${todo.completed ? 'completed' : ''}`}>
              <label>
                <input 
                  type="checkbox" 
                  checked={todo.completed}
                  onChange={() => toggleTodo(todo.id)}
                />
                {todo.title}
              </label>
              <button onClick={() => deleteTodo(todo.id)}>Delete</button>
            </div>
          ))}
      </div>

      <button onClick={() => setShowCompleted(!showCompleted)}>
        {showCompleted ? 'Show All' : 'Show Completed'}
      </button>
    </div>
  );
}

export default App;
```

This implementation includes:

1. Full CRUD operations for todos
2. Database integration with PostgreSQL using SQLAlchemy
3. Async/await support for better performance
4. Pydantic models for data validation
5. Error handling with HTTPException
6. Responsive frontend with React.js
7. State management for the todo list
8. UI features like filtering completed tasks
9. Delete functionality
10. Checkbox toggling for marking tasks as complete

To run this application:

1. Set up your PostgreSQL database and update the `DATABASE_URL` with your credentials.
2. Install all required dependencies (FastAPI, uvicorn, SQLAlchemy, asyncpg, etc.)
3. Run the backend server with `uvicorn todoapp.main:app --reload`
4. Create a React frontend project and integrate the provided React component
5. Start the development server for the React app

You can also add authentication by integrating JWT tokens and user models if needed.

```bash
# Install dependencies
pip install fastapi uvicorn sqlalchemy asyncpg pytest python-multipart[cryptography] python-jose[cryptography] passlib bcrypt

# Run the backend
uvicorn todoapp.main:app --reload

# For the frontend (in a separate directory)
npx create-react-app todo-frontend
cd todo-frontend
npm start
```

This implementation provides a solid foundation for a full-fledged todo application with both backend and frontend components.
